package config

import (
	"encoding/json"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"time"
)

type Config struct {
	User    UserConfig    `json:"user"`
	Network NetworkConfig `json:"network"`
	NATS    NATSConfig    `json:"nats"`
	Routes  RoutesConfig  `json:"routes"`
	UI      UIConfig      `json:"ui"`
	NSC     NSCConfig     `json:"nsc"`
}

type UserConfig struct {
	ID       string `json:"id"`
	Nickname string `json:"nickname"`
	Avatar   string `json:"avatar"`
}

type NetworkConfig struct {
	TailscaleEnabled bool     `json:"tailscale_enabled"`
	AutoDiscovery    bool     `json:"auto_discovery"`
	SeedNodes        []string `json:"seed_nodes"`
	LocalIP          string   `json:"local_ip"`
}

type NATSConfig struct {
	URL           string        `json:"url"`            // NATS server URL
	User          string        `json:"user"`           // Username (legacy compatibility, not recommended)
	Password      string        `json:"password"`       // Password (legacy compatibility, not recommended)
	Token         string        `json:"token"`          // Auth token (optional)
	CredsFile     string        `json:"creds_file"`     // Path to NSC generated .creds file
	Timeout       time.Duration `json:"timeout"`        // Connection timeout
	MaxReconnect  int           `json:"max_reconnect"`  // Max reconnect attempts
	ReconnectWait time.Duration `json:"reconnect_wait"` // Wait duration between reconnects
	Permissions   Permissions   `json:"permissions"`    // Subject permission settings
}

// Permissions encapsulates NATS subject permissions
type Permissions struct {
	Publish   PermissionRules `json:"publish"`   // Publish permissions
	Subscribe PermissionRules `json:"subscribe"` // Subscribe permissions
}

// PermissionRules represents allow/deny lists
type PermissionRules struct {
	Allow []string `json:"allow"` // Allowed subjects
	Deny  []string `json:"deny"`  // Denied subjects
}

type RoutesConfig struct {
	Enabled             bool     `json:"enabled"`              // Whether to enable embedded routes cluster
	Host                string   `json:"host"`                 // Host address
	ClientPort          int      `json:"client_port"`          // Client port
	ClusterPort         int      `json:"cluster_port"`         // Cluster (route) port
	ClusterName         string   `json:"cluster_name"`         // Cluster name
	SeedRoutes          []string `json:"seed_routes"`          // Seed route URLs
	NodeName            string   `json:"node_name"`            // Local node name
	ResolverConfig      string   `json:"resolver_config"`      // Path to nsc generated resolver.conf (enables JWT account resolver)
	BootstrapServers    []string `json:"bootstrap_servers"`    // Optional public bootstrap servers
	BootstrapMinPeers   int      `json:"bootstrap_min_peers"`  // Disconnect bootstrap after reaching this peer count
	DisconnectBootstrap bool     `json:"disconnect_bootstrap"` // Whether to disconnect bootstrap servers after threshold
}

type UIConfig struct {
	Theme    string `json:"theme"`
	Language string `json:"language"`
}

// NSCConfig persists important paths generated by nsc
type NSCConfig struct {
	Operator           string   `json:"operator"`             // Operator name (e.g. local)
	KeysDir            string   `json:"keys_dir"`             // nsc keys directory
	UserCredsPath      string   `json:"user_creds_path"`      // User creds file path (.creds)
	UserSeedPath       string   `json:"user_seed_path"`       // User seed (private) key path if exported
	UserPubKey         string   `json:"user_pub_key"`         // User public NKEY (U...)
	Account            string   `json:"account"`              // Owning account name (default SYS)
	User               string   `json:"user"`                 // User name (default sys)
	TrustedPubKeyPaths []string `json:"trusted_pubkey_paths"` // Trusted public key file paths list
}

var defaultConfig = Config{
	User: UserConfig{
		ID:       "",
		Nickname: "Anonymous",
		Avatar:   "",
	},
	Network: NetworkConfig{
		TailscaleEnabled: true,
		AutoDiscovery:    true,
		SeedNodes:        []string{},
		LocalIP:          "", // Will be resolved dynamically or provided by user
	},
	NATS: NATSConfig{
		URL:           "", // To be filled by user or derived
		User:          "",
		Password:      "",
		Token:         "",
		CredsFile:     "",
		Timeout:       5 * time.Second,
		MaxReconnect:  -1,
		ReconnectWait: time.Second,
		Permissions: Permissions{
			Publish: PermissionRules{
				Allow: []string{"*"}, // Allow publishing to all subjects by default
				Deny:  []string{},
			},
			Subscribe: PermissionRules{
				Allow: []string{}, // Deny all subscriptions by default (explicit allow required)
				Deny:  []string{"*"},
			},
		},
	},
	Routes: RoutesConfig{
		Enabled:             false,
		Host:                "", // To be set
		ClientPort:          0,  // To be set
		ClusterPort:         0,  // To be set
		ClusterName:         "dchat_network",
		SeedRoutes:          []string{},
		NodeName:            "dchat_node",
		ResolverConfig:      "",
		BootstrapServers:    []string{},
		BootstrapMinPeers:   4,
		DisconnectBootstrap: true,
	},
	UI: UIConfig{
		Theme:    "dark",
		Language: "zh-CN",
	},
	NSC: NSCConfig{
		Operator:           "",
		KeysDir:            "",
		UserCredsPath:      "",
		UserSeedPath:       "",
		UserPubKey:         "",
		Account:            "",
		User:               "",
		TrustedPubKeyPaths: []string{},
	},
}

func GetConfigPath() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	configDir := filepath.Join(homeDir, ".dchat")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return "", err
	}

	return filepath.Join(configDir, "config.json"), nil
}

func LoadConfig() (*Config, error) {
	configPath, err := GetConfigPath()
	if err != nil {
		return nil, err
	}

	// 如果配置文件不存在，返回默认配置
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		config := defaultConfig
		if err := config.ValidateAndSetDefaults(); err != nil {
			return nil, fmt.Errorf("failed to set default config: %w", err)
		}
		if err := SaveConfig(&config); err != nil {
			return &config, nil // 返回配置，忽略保存错误
		}
		return &config, nil
	}

	// 读取配置文件
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	// 验证并设置默认值
	if err := config.ValidateAndSetDefaults(); err != nil {
		return nil, fmt.Errorf("failed to validate config: %w", err)
	}

	return &config, nil
}

func SaveConfig(config *Config) error {
	configPath, err := GetConfigPath()
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

func GetDefaultConfig() Config {
	return defaultConfig
}

// GetNATSClientConfig 获取NATS客户端配置
func (c *Config) GetNATSClientConfig() map[string]interface{} {
	return map[string]interface{}{
		"url":            c.NATS.URL,
		"user":           c.NATS.User,
		"password":       c.NATS.Password,
		"token":          c.NATS.Token,
		"creds_file":     c.NATS.CredsFile,
		"name":           c.User.Nickname,
		"timeout":        c.NATS.Timeout,
		"max_reconnect":  c.NATS.MaxReconnect,
		"reconnect_wait": c.NATS.ReconnectWait,
	}
}

// GetRoutesConfig 获取Routes集群配置
func (c *Config) GetRoutesConfig() map[string]interface{} {
	return map[string]interface{}{
		"enabled":              c.Routes.Enabled,
		"host":                 c.Routes.Host,
		"client_port":          c.Routes.ClientPort,
		"cluster_port":         c.Routes.ClusterPort,
		"cluster_name":         c.Routes.ClusterName,
		"seed_routes":          c.Routes.SeedRoutes,
		"node_name":            c.Routes.NodeName,
		"resolver_config":      c.Routes.ResolverConfig,
		"bootstrap_servers":    c.Routes.BootstrapServers,
		"bootstrap_min_peers":  c.Routes.BootstrapMinPeers,
		"disconnect_bootstrap": c.Routes.DisconnectBootstrap,
	}
}

// GetClusterConfig returns cluster related config for higher level managers
func (c *Config) GetClusterConfig() map[string]interface{} {
	return map[string]interface{}{
		"host": c.Routes.Host,
	}
}

// UpdateNATSURL updates the NATS URL
func (c *Config) UpdateNATSURL(url string) {
	c.NATS.URL = url
}

// UpdateUserInfo updates user profile information
func (c *Config) UpdateUserInfo(nickname, avatar string) {
	c.User.Nickname = nickname
	c.User.Avatar = avatar
}

// EnableRoutes enables embedded routes cluster with provided parameters
func (c *Config) EnableRoutes(host string, clientPort int, clusterPort int, seedRoutes []string) {
	c.Routes.Enabled = true
	c.Routes.Host = host
	c.Routes.ClientPort = clientPort
	c.Routes.ClusterPort = clusterPort
	c.Routes.SeedRoutes = seedRoutes
}

// GetLocalIP returns first non-loopback IPv4 address
func GetLocalIP() (string, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "", err
	}

	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String(), nil
			}
		}
	}

	return "", fmt.Errorf("未找到有效的本地IP地址")
}

// ValidateAndSetDefaults validates config and fills missing defaults
func (c *Config) ValidateAndSetDefaults() error {
	// 设置本地IP
	if c.Network.LocalIP == "" {
		localIP, err := GetLocalIP()
		if err != nil {
			// 如果无法获取，使用回环地址作为后备
			c.Network.LocalIP = "127.0.0.1"
		} else {
			c.Network.LocalIP = localIP
		}
	}

	// 设置Routes主机地址
	if c.Routes.Host == "" {
		c.Routes.Host = c.Network.LocalIP
	}

	// 设置NATS URL
	if c.NATS.URL == "" {
		c.NATS.URL = fmt.Sprintf("nats://%s:%d", c.Routes.Host, c.Routes.ClientPort)
	}

	// 确保权限配置完整
	c.ensurePermissionsDefaults()

	return nil
}

// ensurePermissionsDefaults guarantees permission sections have defaults
func (c *Config) ensurePermissionsDefaults() {
	if len(c.NATS.Permissions.Publish.Allow) == 0 && len(c.NATS.Permissions.Publish.Deny) == 0 {
		c.NATS.Permissions.Publish.Allow = []string{"*"}
	}
	if len(c.NATS.Permissions.Subscribe.Allow) == 0 && len(c.NATS.Permissions.Subscribe.Deny) == 0 {
		c.NATS.Permissions.Subscribe.Deny = []string{"*"}
	}
}

// AddSubscribePermission adds a subject to subscribe allow list
func (c *Config) AddSubscribePermission(subject string) {
	// 检查是否已存在
	for _, allowed := range c.NATS.Permissions.Subscribe.Allow {
		if allowed == subject {
			return
		}
	}

	// 添加到允许列表
	c.NATS.Permissions.Subscribe.Allow = append(c.NATS.Permissions.Subscribe.Allow, subject)

	// 从拒绝列表中移除（如果存在）
	c.removeFromDenyList(subject)
}

// AddSubscribePermissionAndSave adds a subscribe permission and persists config
func (c *Config) AddSubscribePermissionAndSave(subject string) error {
	c.AddSubscribePermission(subject)
	return SaveConfig(c)
}

// RemoveSubscribePermission removes a subject from subscribe allow list
func (c *Config) RemoveSubscribePermission(subject string) {
	// 从允许列表中移除
	var newAllow []string
	for _, allowed := range c.NATS.Permissions.Subscribe.Allow {
		if allowed != subject {
			newAllow = append(newAllow, allowed)
		}
	}
	c.NATS.Permissions.Subscribe.Allow = newAllow
}

// RemoveSubscribePermissionAndSave removes a subscribe permission and persists config
func (c *Config) RemoveSubscribePermissionAndSave(subject string) error {
	c.RemoveSubscribePermission(subject)
	return SaveConfig(c)
}

// AddTrustedPubKeyPath adds a trusted public key path (deduplicated) and optionally persists
func (c *Config) AddTrustedPubKeyPath(path string, persist bool) error {
	if path == "" {
		return nil
	}
	for _, p := range c.NSC.TrustedPubKeyPaths {
		if p == path {
			if persist {
				return SaveConfig(c)
			}
			return nil
		}
	}
	c.NSC.TrustedPubKeyPaths = append(c.NSC.TrustedPubKeyPaths, path)
	if persist {
		return SaveConfig(c)
	}
	return nil
}

// removeFromDenyList removes a subject from the deny list if present
func (c *Config) removeFromDenyList(subject string) {
	var newDeny []string
	for _, denied := range c.NATS.Permissions.Subscribe.Deny {
		if denied != subject {
			newDeny = append(newDeny, denied)
		}
	}
	c.NATS.Permissions.Subscribe.Deny = newDeny
}

// CanPublish checks publish permission for given subject
func (c *Config) CanPublish(subject string) bool {
	return c.checkPermission(subject, c.NATS.Permissions.Publish)
}

// CanSubscribe checks subscribe permission for given subject
func (c *Config) CanSubscribe(subject string) bool {
	return c.checkPermission(subject, c.NATS.Permissions.Subscribe)
}

// checkPermission evaluates allow/deny logic for a subject
func (c *Config) checkPermission(subject string, rules PermissionRules) bool {
	// 如果在拒绝列表中，直接返回false
	for _, deny := range rules.Deny {
		if c.matchSubject(subject, deny) {
			return false
		}
	}

	// 如果在允许列表中，返回true
	for _, allow := range rules.Allow {
		if c.matchSubject(subject, allow) {
			return true
		}
	}

	// 默认拒绝
	return false
}

// matchSubject performs simple wildcard subject pattern matching (* suffix)
func (c *Config) matchSubject(subject, pattern string) bool {
	if pattern == "*" {
		return true
	}
	if pattern == subject {
		return true
	}

	// 简单的通配符匹配（可以扩展为更复杂的模式匹配）
	if len(pattern) > 0 && pattern[len(pattern)-1] == '*' {
		prefix := pattern[:len(pattern)-1]
		return len(subject) >= len(prefix) && subject[:len(prefix)] == prefix
	}

	return false
}
